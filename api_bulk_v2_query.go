/*
Salesforce Platform APIs

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 56.0
Contact: russell-laboe@outlook.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package goforce

import (
	"bytes"
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// BulkV2QueryApiService BulkV2QueryApi service
type BulkV2QueryApiService service

type ApiBulkQueryAbortJobRequest struct {
	ctx              context.Context
	ApiService       *BulkV2QueryApiService
	jobId            string
	bulkQueryJobInfo *BulkQueryJobInfo
}

func (r ApiBulkQueryAbortJobRequest) BulkQueryJobInfo(bulkQueryJobInfo BulkQueryJobInfo) ApiBulkQueryAbortJobRequest {
	r.bulkQueryJobInfo = &bulkQueryJobInfo
	return r
}

func (r ApiBulkQueryAbortJobRequest) Execute() (*BulkQueryJobInfo, *http.Response, error) {
	return r.ApiService.BulkQueryAbortJobExecute(r)
}

/*
BulkQueryAbortJob Abort a Job Query

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return ApiBulkQueryAbortJobRequest
*/
func (a *BulkV2QueryApiService) BulkQueryAbortJob(ctx context.Context, jobId string) ApiBulkQueryAbortJobRequest {
	return ApiBulkQueryAbortJobRequest{
		ApiService: a,
		ctx:        ctx,
		jobId:      jobId,
	}
}

// Execute executes the request
//
//	@return BulkQueryJobInfo
func (a *BulkV2QueryApiService) BulkQueryAbortJobExecute(r ApiBulkQueryAbortJobRequest) (*BulkQueryJobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkQueryJobInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkV2QueryApiService.BulkQueryAbortJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/query/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkQueryJobInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkQueryCreateJobRequest struct {
	ctx                       context.Context
	ApiService                *BulkV2QueryApiService
	contentType               *string
	bulkQueryJobCreateRequest *BulkQueryJobCreateRequest
}

func (r ApiBulkQueryCreateJobRequest) ContentType(contentType string) ApiBulkQueryCreateJobRequest {
	r.contentType = &contentType
	return r
}

func (r ApiBulkQueryCreateJobRequest) BulkQueryJobCreateRequest(bulkQueryJobCreateRequest BulkQueryJobCreateRequest) ApiBulkQueryCreateJobRequest {
	r.bulkQueryJobCreateRequest = &bulkQueryJobCreateRequest
	return r
}

func (r ApiBulkQueryCreateJobRequest) Execute() (*BulkQueryJobInfo, *http.Response, error) {
	return r.ApiService.BulkQueryCreateJobExecute(r)
}

/*
BulkQueryCreateJob Create job Query

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBulkQueryCreateJobRequest
*/
func (a *BulkV2QueryApiService) BulkQueryCreateJob(ctx context.Context) ApiBulkQueryCreateJobRequest {
	return ApiBulkQueryCreateJobRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BulkQueryJobInfo
func (a *BulkV2QueryApiService) BulkQueryCreateJobExecute(r ApiBulkQueryCreateJobRequest) (*BulkQueryJobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkQueryJobInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkV2QueryApiService.BulkQueryCreateJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentType != nil {
		localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	}
	// body params
	localVarPostBody = r.bulkQueryJobCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkQueryDeleteJobRequest struct {
	ctx        context.Context
	ApiService *BulkV2QueryApiService
	jobId      string
}

func (r ApiBulkQueryDeleteJobRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkQueryDeleteJobExecute(r)
}

/*
BulkQueryDeleteJob Delete Job Query

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return ApiBulkQueryDeleteJobRequest
*/
func (a *BulkV2QueryApiService) BulkQueryDeleteJob(ctx context.Context, jobId string) ApiBulkQueryDeleteJobRequest {
	return ApiBulkQueryDeleteJobRequest{
		ApiService: a,
		ctx:        ctx,
		jobId:      jobId,
	}
}

// Execute executes the request
func (a *BulkV2QueryApiService) BulkQueryDeleteJobExecute(r ApiBulkQueryDeleteJobRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkV2QueryApiService.BulkQueryDeleteJob")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/query/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarHTTPResponse, err
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBulkQueryJobInfoRequest struct {
	ctx        context.Context
	ApiService *BulkV2QueryApiService
	jobId      string
}

func (r ApiBulkQueryJobInfoRequest) Execute() (*BulkQueryJobInfo, *http.Response, error) {
	return r.ApiService.BulkQueryJobInfoExecute(r)
}

/*
BulkQueryJobInfo Get Job Info Query

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return ApiBulkQueryJobInfoRequest
*/
func (a *BulkV2QueryApiService) BulkQueryJobInfo(ctx context.Context, jobId string) ApiBulkQueryJobInfoRequest {
	return ApiBulkQueryJobInfoRequest{
		ApiService: a,
		ctx:        ctx,
		jobId:      jobId,
	}
}

// Execute executes the request
//
//	@return BulkQueryJobInfo
func (a *BulkV2QueryApiService) BulkQueryJobInfoExecute(r ApiBulkQueryJobInfoRequest) (*BulkQueryJobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkQueryJobInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkV2QueryApiService.BulkQueryJobInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/query/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkQueryJobResultsRequest struct {
	ctx         context.Context
	ApiService  *BulkV2QueryApiService
	jobId       string
	contentType *string
	accept      *string
	locator     *string
	maxRecords  *int32
}

func (r ApiBulkQueryJobResultsRequest) ContentType(contentType string) ApiBulkQueryJobResultsRequest {
	r.contentType = &contentType
	return r
}

func (r ApiBulkQueryJobResultsRequest) Accept(accept string) ApiBulkQueryJobResultsRequest {
	r.accept = &accept
	return r
}

// A string that identifies a specific set of query results. Providing a value for this parameter returns only that set of results. Omitting this parameter returns the first set of results.  You can find the locator string for the next set of results in the response of each request. See Example and Rules and Guidelines.  As long as the associated job exists, the locator string for a set of results does not change. You can use the locator to retrieve a set of results multiple times.
func (r ApiBulkQueryJobResultsRequest) Locator(locator string) ApiBulkQueryJobResultsRequest {
	r.locator = &locator
	return r
}

// The maximum number of records to retrieve per set of results for the query. The request is still subject to the size limits. If you are working with a very large number of query results, you may experience a timeout before receiving all the data from Salesforce. To prevent a timeout, specify the maximum number of records your client is expecting to receive in the maxRecords parameter. This splits the results into smaller sets with this value as the maximum size.  If you donâ€™t provide a value for this parameter, the server uses a default value based on the service.
func (r ApiBulkQueryJobResultsRequest) MaxRecords(maxRecords int32) ApiBulkQueryJobResultsRequest {
	r.maxRecords = &maxRecords
	return r
}

func (r ApiBulkQueryJobResultsRequest) Execute() (*io.ReadCloser, *http.Response, error) {
	return r.ApiService.BulkQueryJobResultsExecute(r)
}

/*
BulkQueryJobResults Get Job Query Result

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return ApiBulkQueryJobResultsRequest
*/
func (a *BulkV2QueryApiService) BulkQueryJobResults(ctx context.Context, jobId string) ApiBulkQueryJobResultsRequest {
	return ApiBulkQueryJobResultsRequest{
		ApiService: a,
		ctx:        ctx,
		jobId:      jobId,
	}
}

// Execute executes the request
//
//	@return io.ReadCloser
func (a *BulkV2QueryApiService) BulkQueryJobResultsExecute(r ApiBulkQueryJobResultsRequest) (*io.ReadCloser, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *io.ReadCloser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkV2QueryApiService.BulkQueryJobResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/query/{jobId}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.locator != nil {
		localVarQueryParams.Add("locator", parameterToString(*r.locator, ""))
	}
	if r.maxRecords != nil {
		localVarQueryParams.Add("maxRecords", parameterToString(*r.maxRecords, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentType != nil {
		localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	}
	if r.accept != nil {
		localVarHeaderParams["Accept"] = parameterToString(*r.accept, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarHTTPResponse.Body, localVarHTTPResponse, nil
}

type ApiBulkQueryJobsRequest struct {
	ctx                 context.Context
	ApiService          *BulkV2QueryApiService
	isPkChunkingEnabled *bool
	jobType             *string
	concurrencyMode     *string
	queryLocator        *string
}

// If set to true, the request only returns information about jobs where PK Chunking is enabled.
func (r ApiBulkQueryJobsRequest) IsPkChunkingEnabled(isPkChunkingEnabled bool) ApiBulkQueryJobsRequest {
	r.isPkChunkingEnabled = &isPkChunkingEnabled
	return r
}

// Gets information only about jobs matching the specified job type.
func (r ApiBulkQueryJobsRequest) JobType(jobType string) ApiBulkQueryJobsRequest {
	r.jobType = &jobType
	return r
}

// For future use. Gets information only about jobs matching the specified concurrency mode. Possible values are serial and parallel.
func (r ApiBulkQueryJobsRequest) ConcurrencyMode(concurrencyMode string) ApiBulkQueryJobsRequest {
	r.concurrencyMode = &concurrencyMode
	return r
}

// use the value from the nextRecordsUrl from the previous set
func (r ApiBulkQueryJobsRequest) QueryLocator(queryLocator string) ApiBulkQueryJobsRequest {
	r.queryLocator = &queryLocator
	return r
}

func (r ApiBulkQueryJobsRequest) Execute() (*BulkQueryJobsInfos, *http.Response, error) {
	return r.ApiService.BulkQueryJobsExecute(r)
}

/*
BulkQueryJobs Get All Query Jobs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBulkQueryJobsRequest
*/
func (a *BulkV2QueryApiService) BulkQueryJobs(ctx context.Context) ApiBulkQueryJobsRequest {
	return ApiBulkQueryJobsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BulkQueryJobsInfos
func (a *BulkV2QueryApiService) BulkQueryJobsExecute(r ApiBulkQueryJobsRequest) (*BulkQueryJobsInfos, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkQueryJobsInfos
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkV2QueryApiService.BulkQueryJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isPkChunkingEnabled != nil {
		localVarQueryParams.Add("isPkChunkingEnabled", parameterToString(*r.isPkChunkingEnabled, ""))
	}
	if r.jobType != nil {
		localVarQueryParams.Add("jobType", parameterToString(*r.jobType, ""))
	}
	if r.concurrencyMode != nil {
		localVarQueryParams.Add("concurrencyMode", parameterToString(*r.concurrencyMode, ""))
	}
	if r.queryLocator != nil {
		localVarQueryParams.Add("queryLocator", parameterToString(*r.queryLocator, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
