/*
Salesforce Platform Bulk V2 API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 56.0
Contact: russell-laboe@outlook.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bulkv2

import (
	"bytes"
	"compress/gzip"
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// QueryApiService QueryApi service
type QueryApiService service

type ApiAbortQueryJobRequest struct {
	ctx                  context.Context
	ApiService           *QueryApiService
	jobId                string
	abortQueryJobRequest *AbortQueryJobRequest
	contentEncoding      *EncodingType
}

func (r ApiAbortQueryJobRequest) AbortQueryJobRequest(abortQueryJobRequest AbortQueryJobRequest) ApiAbortQueryJobRequest {
	r.abortQueryJobRequest = &abortQueryJobRequest
	return r
}

func (r ApiAbortQueryJobRequest) ContentEncoding(contentEncoding EncodingType) ApiAbortQueryJobRequest {
	r.contentEncoding = &contentEncoding
	return r
}

func (r ApiAbortQueryJobRequest) Execute() (*QueryJobInfo, *http.Response, error) {
	return r.ApiService.AbortQueryJobExecute(r)
}

/*
AbortQueryJob Abort a Query Job

Aborts a query job.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return ApiAbortQueryJobRequest
*/
func (a *QueryApiService) AbortQueryJob(ctx context.Context, jobId string) ApiAbortQueryJobRequest {
	return ApiAbortQueryJobRequest{
		ApiService: a,
		ctx:        ctx,
		jobId:      jobId,
	}
}

// Execute executes the request
//
//	@return QueryJobInfo
func (a *QueryApiService) AbortQueryJobExecute(r ApiAbortQueryJobRequest) (*QueryJobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QueryJobInfo
	)

	token, err := a.client.tokenSrc.Token()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	activeServer := a.client.cfg.GetActiveServer()
	activeServer.SetServerVariable("instanceUrl", token.Extra("instance_url").(string))

	localVarPath := activeServer.GetURL() + "/jobs/query/{jobId}"
	pathParams := map[string]string{
		"jobId": url.PathEscape(parameterToString(strings.Trim(r.jobId, " "), "")),
	}
	localVarPath = injectUrlVars(localVarPath, pathParams)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.abortQueryJobRequest == nil {
		return localVarReturnValue, nil, reportError("abortQueryJobRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentEncoding != nil {
		localVarHeaderParams["Content-Encoding"] = parameterToString(*r.contentEncoding, "")
	}
	// body params
	localVarPostBody = r.abortQueryJobRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	token.SetAuthHeader(req)

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	respBodyReadCloser := localVarHTTPResponse.Body
	if localVarHTTPResponse.Header.Get("Content-Encoding") == "gzip" {
		respBodyReadCloser, err = gzip.NewReader(localVarHTTPResponse.Body)
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, err := ioutil.ReadAll(respBodyReadCloser)
		localVarHTTPResponse.Body.Close()
		respBodyReadCloser.Close()
		localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	localVarBody, err := ioutil.ReadAll(respBodyReadCloser)
	localVarHTTPResponse.Body.Close()
	respBodyReadCloser.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateQueryJobRequest struct {
	ctx                   context.Context
	ApiService            *QueryApiService
	createQueryJobRequest *CreateQueryJobRequest
	sforceCallOptions     *string
	contentEncoding       *EncodingType
	acceptEncoding        *EncodingType
}

func (r ApiCreateQueryJobRequest) CreateQueryJobRequest(createQueryJobRequest CreateQueryJobRequest) ApiCreateQueryJobRequest {
	r.createQueryJobRequest = &createQueryJobRequest
	return r
}

func (r ApiCreateQueryJobRequest) SforceCallOptions(sforceCallOptions string) ApiCreateQueryJobRequest {
	r.sforceCallOptions = &sforceCallOptions
	return r
}

func (r ApiCreateQueryJobRequest) ContentEncoding(contentEncoding EncodingType) ApiCreateQueryJobRequest {
	r.contentEncoding = &contentEncoding
	return r
}

func (r ApiCreateQueryJobRequest) AcceptEncoding(acceptEncoding EncodingType) ApiCreateQueryJobRequest {
	r.acceptEncoding = &acceptEncoding
	return r
}

func (r ApiCreateQueryJobRequest) Execute() (*QueryJobInfo, *http.Response, error) {
	return r.ApiService.CreateQueryJobExecute(r)
}

/*
CreateQueryJob Create a Query Job

Creates a query job.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateQueryJobRequest
*/
func (a *QueryApiService) CreateQueryJob(ctx context.Context) ApiCreateQueryJobRequest {
	return ApiCreateQueryJobRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return QueryJobInfo
func (a *QueryApiService) CreateQueryJobExecute(r ApiCreateQueryJobRequest) (*QueryJobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QueryJobInfo
	)

	token, err := a.client.tokenSrc.Token()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	activeServer := a.client.cfg.GetActiveServer()
	activeServer.SetServerVariable("instanceUrl", token.Extra("instance_url").(string))

	localVarPath := activeServer.GetURL() + "/jobs/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createQueryJobRequest == nil {
		return localVarReturnValue, nil, reportError("createQueryJobRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.sforceCallOptions != nil {
		localVarHeaderParams["Sforce-Call-Options"] = parameterToString(*r.sforceCallOptions, "")
	}
	if r.contentEncoding != nil {
		localVarHeaderParams["Content-Encoding"] = parameterToString(*r.contentEncoding, "")
	}
	if r.acceptEncoding != nil {
		localVarHeaderParams["Accept-Encoding"] = parameterToString(*r.acceptEncoding, "")
	}
	// body params
	localVarPostBody = r.createQueryJobRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	token.SetAuthHeader(req)

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	respBodyReadCloser := localVarHTTPResponse.Body
	if localVarHTTPResponse.Header.Get("Content-Encoding") == "gzip" {
		respBodyReadCloser, err = gzip.NewReader(localVarHTTPResponse.Body)
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, err := ioutil.ReadAll(respBodyReadCloser)
		localVarHTTPResponse.Body.Close()
		respBodyReadCloser.Close()
		localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	localVarBody, err := ioutil.ReadAll(respBodyReadCloser)
	localVarHTTPResponse.Body.Close()
	respBodyReadCloser.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteQueryJobRequest struct {
	ctx        context.Context
	ApiService *QueryApiService
	jobId      string
}

func (r ApiDeleteQueryJobRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteQueryJobExecute(r)
}

/*
DeleteQueryJob Delete a Query Job

Deletes a query job. When a job is deleted, job data stored by Salesforce is deleted and job metadata information is removed. The job no longer displays in the Bulk Data Load Jobs page in Salesforce.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return ApiDeleteQueryJobRequest
*/
func (a *QueryApiService) DeleteQueryJob(ctx context.Context, jobId string) ApiDeleteQueryJobRequest {
	return ApiDeleteQueryJobRequest{
		ApiService: a,
		ctx:        ctx,
		jobId:      jobId,
	}
}

// Execute executes the request
func (a *QueryApiService) DeleteQueryJobExecute(r ApiDeleteQueryJobRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	token, err := a.client.tokenSrc.Token()
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	activeServer := a.client.cfg.GetActiveServer()
	activeServer.SetServerVariable("instanceUrl", token.Extra("instance_url").(string))

	localVarPath := activeServer.GetURL() + "/jobs/query/{jobId}"
	pathParams := map[string]string{
		"jobId": url.PathEscape(parameterToString(strings.Trim(r.jobId, " "), "")),
	}
	localVarPath = injectUrlVars(localVarPath, pathParams)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	token.SetAuthHeader(req)

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	respBodyReadCloser := localVarHTTPResponse.Body
	if localVarHTTPResponse.Header.Get("Content-Encoding") == "gzip" {
		respBodyReadCloser, err = gzip.NewReader(localVarHTTPResponse.Body)
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, err := ioutil.ReadAll(respBodyReadCloser)
		localVarHTTPResponse.Body.Close()
		respBodyReadCloser.Close()
		localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarHTTPResponse, err
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetQueryJobInfoRequest struct {
	ctx            context.Context
	ApiService     *QueryApiService
	jobId          string
	acceptEncoding *EncodingType
}

func (r ApiGetQueryJobInfoRequest) AcceptEncoding(acceptEncoding EncodingType) ApiGetQueryJobInfoRequest {
	r.acceptEncoding = &acceptEncoding
	return r
}

func (r ApiGetQueryJobInfoRequest) Execute() (*QueryJobInfo, *http.Response, error) {
	return r.ApiService.GetQueryJobInfoExecute(r)
}

/*
GetQueryJobInfo Get Information About a Query Job

Gets information about one query job.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return ApiGetQueryJobInfoRequest
*/
func (a *QueryApiService) GetQueryJobInfo(ctx context.Context, jobId string) ApiGetQueryJobInfoRequest {
	return ApiGetQueryJobInfoRequest{
		ApiService: a,
		ctx:        ctx,
		jobId:      jobId,
	}
}

// Execute executes the request
//
//	@return QueryJobInfo
func (a *QueryApiService) GetQueryJobInfoExecute(r ApiGetQueryJobInfoRequest) (*QueryJobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QueryJobInfo
	)

	token, err := a.client.tokenSrc.Token()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	activeServer := a.client.cfg.GetActiveServer()
	activeServer.SetServerVariable("instanceUrl", token.Extra("instance_url").(string))

	localVarPath := activeServer.GetURL() + "/jobs/query/{jobId}"
	pathParams := map[string]string{
		"jobId": url.PathEscape(parameterToString(strings.Trim(r.jobId, " "), "")),
	}
	localVarPath = injectUrlVars(localVarPath, pathParams)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptEncoding != nil {
		localVarHeaderParams["Accept-Encoding"] = parameterToString(*r.acceptEncoding, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	token.SetAuthHeader(req)

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	respBodyReadCloser := localVarHTTPResponse.Body
	if localVarHTTPResponse.Header.Get("Content-Encoding") == "gzip" {
		respBodyReadCloser, err = gzip.NewReader(localVarHTTPResponse.Body)
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, err := ioutil.ReadAll(respBodyReadCloser)
		localVarHTTPResponse.Body.Close()
		respBodyReadCloser.Close()
		localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	localVarBody, err := ioutil.ReadAll(respBodyReadCloser)
	localVarHTTPResponse.Body.Close()
	respBodyReadCloser.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQueryJobResultsRequest struct {
	ctx            context.Context
	ApiService     *QueryApiService
	jobId          string
	acceptEncoding *EncodingType
	locator        *string
	maxRecords     *int32
}

func (r ApiGetQueryJobResultsRequest) AcceptEncoding(acceptEncoding EncodingType) ApiGetQueryJobResultsRequest {
	r.acceptEncoding = &acceptEncoding
	return r
}

// A string that identifies a specific set of query results. Providing a value for this parameter returns only that set of results. Omitting this parameter returns the first set of results.  You can find the locator string for the next set of results in the response of each request. See Example and Rules and Guidelines.  As long as the associated job exists, the locator string for a set of results does not change. You can use the locator to retrieve a set of results multiple times.
func (r ApiGetQueryJobResultsRequest) Locator(locator string) ApiGetQueryJobResultsRequest {
	r.locator = &locator
	return r
}

// The maximum number of records to retrieve per set of results for the query. The request is still subject to the size limits. If you are working with a very large number of query results, you may experience a timeout before receiving all the data from Salesforce. To prevent a timeout, specify the maximum number of records your client is expecting to receive in the maxRecords parameter. This splits the results into smaller sets with this value as the maximum size.  If you donâ€™t provide a value for this parameter, the server uses a default value based on the service.
func (r ApiGetQueryJobResultsRequest) MaxRecords(maxRecords int32) ApiGetQueryJobResultsRequest {
	r.maxRecords = &maxRecords
	return r
}

func (r ApiGetQueryJobResultsRequest) Execute() (*io.ReadCloser, *http.Response, error) {
	return r.ApiService.GetQueryJobResultsExecute(r)
}

/*
GetQueryJobResults Get Results for a Query Job

Gets the results for a query job. The job must have the state `JobComplete`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return ApiGetQueryJobResultsRequest
*/
func (a *QueryApiService) GetQueryJobResults(ctx context.Context, jobId string) ApiGetQueryJobResultsRequest {
	return ApiGetQueryJobResultsRequest{
		ApiService: a,
		ctx:        ctx,
		jobId:      jobId,
	}
}

// Execute executes the request
//
//	@return io.ReadCloser
func (a *QueryApiService) GetQueryJobResultsExecute(r ApiGetQueryJobResultsRequest) (*io.ReadCloser, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *io.ReadCloser
	)

	token, err := a.client.tokenSrc.Token()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	activeServer := a.client.cfg.GetActiveServer()
	activeServer.SetServerVariable("instanceUrl", token.Extra("instance_url").(string))

	localVarPath := activeServer.GetURL() + "/jobs/query/{jobId}/results"
	pathParams := map[string]string{
		"jobId": url.PathEscape(parameterToString(strings.Trim(r.jobId, " "), "")),
	}
	localVarPath = injectUrlVars(localVarPath, pathParams)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.locator != nil {
		localVarQueryParams.Add("locator", parameterToString(*r.locator, ""))
	}
	if r.maxRecords != nil {
		localVarQueryParams.Add("maxRecords", parameterToString(*r.maxRecords, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptEncoding != nil {
		localVarHeaderParams["Accept-Encoding"] = parameterToString(*r.acceptEncoding, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	token.SetAuthHeader(req)

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	respBodyReadCloser := localVarHTTPResponse.Body
	if localVarHTTPResponse.Header.Get("Content-Encoding") == "gzip" {
		respBodyReadCloser, err = gzip.NewReader(localVarHTTPResponse.Body)
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, err := ioutil.ReadAll(respBodyReadCloser)
		localVarHTTPResponse.Body.Close()
		respBodyReadCloser.Close()
		localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &respBodyReadCloser, localVarHTTPResponse, nil
}

type ApiGetQueryJobsRequest struct {
	ctx                 context.Context
	ApiService          *QueryApiService
	isPkChunkingEnabled *bool
	jobType             *string
	concurrencyMode     *string
	queryLocator        *string
	acceptEncoding      *EncodingType
}

// If set to true, the request only returns information about jobs where PK Chunking is enabled.
func (r ApiGetQueryJobsRequest) IsPkChunkingEnabled(isPkChunkingEnabled bool) ApiGetQueryJobsRequest {
	r.isPkChunkingEnabled = &isPkChunkingEnabled
	return r
}

// Gets information only about jobs matching the specified job type.
func (r ApiGetQueryJobsRequest) JobType(jobType string) ApiGetQueryJobsRequest {
	r.jobType = &jobType
	return r
}

// For future use. Gets information only about jobs matching the specified concurrency mode. Possible values are serial and parallel.
func (r ApiGetQueryJobsRequest) ConcurrencyMode(concurrencyMode string) ApiGetQueryJobsRequest {
	r.concurrencyMode = &concurrencyMode
	return r
}

// use the value from the nextRecordsUrl from the previous set
func (r ApiGetQueryJobsRequest) QueryLocator(queryLocator string) ApiGetQueryJobsRequest {
	r.queryLocator = &queryLocator
	return r
}

func (r ApiGetQueryJobsRequest) AcceptEncoding(acceptEncoding EncodingType) ApiGetQueryJobsRequest {
	r.acceptEncoding = &acceptEncoding
	return r
}

func (r ApiGetQueryJobsRequest) Execute() (*QueryJobInfos, *http.Response, error) {
	return r.ApiService.GetQueryJobsExecute(r)
}

/*
GetQueryJobs Get Information About All Query Jobs

Gets information about all query jobs in the org. The information includes Bulk API 2.0 query jobs and all Bulk API jobs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetQueryJobsRequest
*/
func (a *QueryApiService) GetQueryJobs(ctx context.Context) ApiGetQueryJobsRequest {
	return ApiGetQueryJobsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return QueryJobInfos
func (a *QueryApiService) GetQueryJobsExecute(r ApiGetQueryJobsRequest) (*QueryJobInfos, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QueryJobInfos
	)

	token, err := a.client.tokenSrc.Token()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	activeServer := a.client.cfg.GetActiveServer()
	activeServer.SetServerVariable("instanceUrl", token.Extra("instance_url").(string))

	localVarPath := activeServer.GetURL() + "/jobs/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isPkChunkingEnabled != nil {
		localVarQueryParams.Add("isPkChunkingEnabled", parameterToString(*r.isPkChunkingEnabled, ""))
	}
	if r.jobType != nil {
		localVarQueryParams.Add("jobType", parameterToString(*r.jobType, ""))
	}
	if r.concurrencyMode != nil {
		localVarQueryParams.Add("concurrencyMode", parameterToString(*r.concurrencyMode, ""))
	}
	if r.queryLocator != nil {
		localVarQueryParams.Add("queryLocator", parameterToString(*r.queryLocator, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptEncoding != nil {
		localVarHeaderParams["Accept-Encoding"] = parameterToString(*r.acceptEncoding, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	token.SetAuthHeader(req)

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	respBodyReadCloser := localVarHTTPResponse.Body
	if localVarHTTPResponse.Header.Get("Content-Encoding") == "gzip" {
		respBodyReadCloser, err = gzip.NewReader(localVarHTTPResponse.Body)
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, err := ioutil.ReadAll(respBodyReadCloser)
		localVarHTTPResponse.Body.Close()
		respBodyReadCloser.Close()
		localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	localVarBody, err := ioutil.ReadAll(respBodyReadCloser)
	localVarHTTPResponse.Body.Close()
	respBodyReadCloser.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
